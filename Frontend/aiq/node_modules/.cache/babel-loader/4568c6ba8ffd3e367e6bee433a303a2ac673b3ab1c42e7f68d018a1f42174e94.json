{"ast":null,"code":"import { useState, useEffect, useMemo, useCallback, createRef } from 'react';\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nfunction createStore(store2) {\n  return (stateUpdater, callbacks) => {\n    return new Proxy(store2, {\n      get(target, prop, receiver) {\n        if (prop === \"size\") {\n          return target.size;\n        }\n        const value = Reflect.get(target, prop, receiver);\n        if (value instanceof Function) {\n          return function (...args) {\n            var _a2;\n            const result = value.apply(target, args);\n            const shouldTriggerUpdate = args[args.length - 1] === true;\n            if (shouldTriggerUpdate) {\n              stateUpdater(prev => prev + 1);\n            }\n            if (prop === \"set\") {\n              return result.get(args[0]);\n            }\n            if (callbacks && callbacks[prop]) {\n              (_a2 = callbacks[prop]) == null ? void 0 : _a2.call(callbacks, result);\n            }\n            return result;\n          };\n        }\n        return value;\n      }\n    });\n  };\n}\nfunction useStore(store2, callbacks) {\n  const [, forceUpdate] = useState(0);\n  const triggerUpdate = useCallback(() => forceUpdate(prev => prev + 1), []);\n  const state = useMemo(() => store2(triggerUpdate, callbacks), []);\n  return {\n    state\n  };\n}\n\n// src/codec.ts\nfunction checkRecordingCodecSupport(codec) {\n  if (typeof MediaRecorder === \"undefined\") return false;\n  return MediaRecorder.isTypeSupported(codec);\n}\nfunction checkVideoCodecPlaybackSupport(codec) {\n  const video = document.createElement(\"video\");\n  const canPlay = video.canPlayType(codec);\n  return canPlay === \"maybe\" || canPlay === \"probably\" ? true : false;\n}\nfunction checkAudioCodecPlaybackSupport(codec) {\n  const audio = document.createElement(\"audio\");\n  const canPlay = audio.canPlayType(codec);\n  return canPlay === \"maybe\" || canPlay === \"probably\" ? true : false;\n}\nvar audioContainers = [\"ogg\", \"aac\", \"flac\", \"wav\", \"mp4\"];\nvar videoContainers = [\"webm\", \"mp4\", \"x-matroska\", \"3gpp\", \"3gpp2\", \"3gp2\", \"quicktime\", \"mpeg\"];\nvar audioCodecs = [\"opus\", \"pcm\", \"aac\", \"mp4a\"];\nvar videoCodecs = [\"vp9\", \"vp8\", \"avc1\", \"av1\", \"h265\", \"h.264\", \"h264\", \"mpeg\"];\nfunction getSupportedMediaFormats(containers, codecs, type) {\n  return containers.reduce((acc, container) => {\n    codecs.forEach(codec => {\n      const mimeType = `${type}/${container};codecs=${codec}`;\n      if (typeof MediaRecorder !== \"undefined\" && MediaRecorder.isTypeSupported(mimeType)) {\n        acc.mimeType.push(mimeType);\n        acc.codec.push(codec);\n        acc.container.push(container);\n      }\n    });\n    return acc;\n  }, {\n    mimeType: [],\n    codec: [],\n    container: []\n  });\n}\nvar supportedAudioCodecs = getSupportedMediaFormats(audioContainers, audioCodecs, \"audio\");\nvar supportedVideoCodecs = getSupportedMediaFormats(videoContainers, videoCodecs, \"video\");\nvar videoContainer = supportedVideoCodecs.container[0];\nvar videoCodec = supportedVideoCodecs.codec[0];\nvar _a;\nvar audioCodec = (_a = supportedAudioCodecs == null ? void 0 : supportedAudioCodecs.codec) == null ? void 0 : _a[0];\nvar defaultCodec = `video/${videoContainer};codecs=${videoCodec}${audioCodec ? `,${audioCodec}` : \"\"}`;\n\n// src/useRecordingStore.ts\nvar ERROR_MESSAGES = {\n  CODEC_NOT_SUPPORTED: \"CODEC_NOT_SUPPORTED\",\n  SESSION_EXISTS: \"SESSION_EXISTS\",\n  NO_RECORDING_WITH_ID: \"NO_RECORDING_WITH_ID\",\n  NO_USER_PERMISSION: \"NO_USER_PERMISSION\"\n};\nvar STATUS = {\n  INITIAL: \"INITIAL\",\n  CLOSED: \"CLOSED\",\n  OPEN: \"OPEN\",\n  RECORDING: \"RECORDING\",\n  STOPPED: \"STOPPED\",\n  ERROR: \"ERROR\",\n  PAUSED: \"PAUSED\"\n};\nfunction createRecording({\n  videoId,\n  audioId,\n  videoLabel,\n  audioLabel\n}) {\n  const recordingId = `${videoId}-${audioId}`;\n  const recording = {\n    id: recordingId,\n    audioId,\n    audioLabel,\n    blobChunks: [],\n    fileName: String((/* @__PURE__ */new Date()).getTime()),\n    fileType: \"webm\",\n    isMuted: false,\n    mimeType: defaultCodec,\n    objectURL: null,\n    previewRef: createRef(),\n    recorder: null,\n    status: STATUS.INITIAL,\n    videoId,\n    videoLabel,\n    webcamRef: createRef()\n  };\n  return recording;\n}\nvar recordingMap = /* @__PURE__ */new Map();\nvar store = createStore(recordingMap);\nfunction useRecordingStore() {\n  var _a2;\n  const {\n    state\n  } = useStore(store);\n  const activeRecordings = Array.from((_a2 = recordingMap == null ? void 0 : recordingMap.values) == null ? void 0 : _a2.call(recordingMap));\n  const clearAllRecordings = () => __async(this, null, function* () {\n    Array.from(state.values()).forEach(recording => {\n      var _a3;\n      const stream = (_a3 = recording.webcamRef.current) == null ? void 0 : _a3.srcObject;\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n    });\n    state.clear(true);\n  });\n  const isRecordingCreated = recordingId => {\n    const isCreated = state.get(recordingId);\n    return Boolean(isCreated);\n  };\n  const getRecording = recordingId => {\n    const recording = state.get(recordingId);\n    if (!recording) {\n      throw new Error(ERROR_MESSAGES.NO_RECORDING_WITH_ID);\n    }\n    return recording;\n  };\n  const setRecording = params => __async(this, null, function* () {\n    const recording = createRecording(params);\n    const newRecording = state.set(recording.id, recording, true);\n    return newRecording;\n  });\n  const updateRecording = (recordingId, updatedValues) => __async(this, null, function* () {\n    const recording = state.get(recordingId);\n    const updatedRecording = state.set(recordingId, __spreadValues(__spreadValues({}, recording), updatedValues), true);\n    return updatedRecording;\n  });\n  const deleteRecording = recordingId => __async(this, null, function* () {\n    state.delete(recordingId, true);\n  });\n  return {\n    activeRecordings,\n    clearAllRecordings,\n    deleteRecording,\n    getRecording,\n    isRecordingCreated,\n    setRecording,\n    updateRecording\n  };\n}\n\n// src/devices.ts\nfunction byId(devices) {\n  return devices.reduce((result, {\n    deviceId,\n    kind,\n    label\n  }) => {\n    if (kind === \"videoinput\" || kind === \"audioinput\") {\n      result[deviceId] = {\n        label,\n        type: kind\n      };\n    }\n    return result;\n  }, {});\n}\nfunction byType(devices) {\n  return devices.reduce((result, {\n    deviceId,\n    kind,\n    label\n  }) => {\n    if (kind === \"videoinput\") {\n      result.video.push({\n        label,\n        deviceId\n      });\n    }\n    if (kind === \"audioinput\") {\n      result.audio.push({\n        label,\n        deviceId\n      });\n    }\n    return result;\n  }, {\n    video: [],\n    audio: []\n  });\n}\nfunction getUserPermission() {\n  return __async(this, null, function* () {\n    try {\n      const stream = yield navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: true\n      });\n      const mediaDevices = yield navigator.mediaDevices.enumerateDevices();\n      stream.getTracks().forEach(track => {\n        track.stop();\n      });\n      return mediaDevices;\n    } catch (error) {\n      throw new Error(ERROR_MESSAGES.NO_USER_PERMISSION);\n    }\n  });\n}\nfunction getDevices() {\n  return __async(this, null, function* () {\n    let devicesByType = {\n      video: [],\n      audio: []\n    };\n    let devicesById = {};\n    let initialDevices = {\n      video: null,\n      audio: null\n    };\n    if (typeof window !== \"undefined\") {\n      const mediaDevices = yield getUserPermission();\n      devicesById = byId(mediaDevices);\n      devicesByType = byType(mediaDevices);\n      initialDevices = {\n        video: {\n          deviceId: devicesByType.video[0].deviceId,\n          label: devicesByType.video[0].label\n        },\n        audio: {\n          deviceId: devicesByType.audio[0].deviceId,\n          label: devicesByType.audio[0].label\n        }\n      };\n    }\n    return {\n      devicesByType,\n      devicesById,\n      initialDevices\n    };\n  });\n}\nvar DEFAULT_RECORDER_OPTIONS = {\n  audioBitsPerSecond: 128e3,\n  videoBitsPerSecond: 25e5,\n  mimeType: defaultCodec\n};\nfunction useRecorder({\n  mediaRecorderOptions,\n  options,\n  devices,\n  handleError\n}) {\n  const {\n    activeRecordings,\n    clearAllRecordings,\n    deleteRecording,\n    getRecording,\n    isRecordingCreated,\n    setRecording,\n    updateRecording\n  } = useRecordingStore();\n  const recorderOptions = useMemo(() => __spreadValues(__spreadValues({}, DEFAULT_RECORDER_OPTIONS), mediaRecorderOptions), [mediaRecorderOptions]);\n  const startRecording = recordingId => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      const stream = (_a2 = recording.webcamRef.current) == null ? void 0 : _a2.srcObject;\n      recording.mimeType = recorderOptions.mimeType || recording.mimeType;\n      const isCodecSupported = MediaRecorder.isTypeSupported(recording.mimeType);\n      if (!isCodecSupported) {\n        console.warn(\"Codec not supported: \", recording.mimeType);\n        handleError(\"startRecording\", ERROR_MESSAGES.CODEC_NOT_SUPPORTED);\n      }\n      recording.recorder = new MediaRecorder(stream, recorderOptions);\n      return yield new Promise(resolve => {\n        var _a3;\n        if (recording.recorder) {\n          recording.recorder.ondataavailable = event => {\n            if (event.data.size) {\n              recording.blobChunks.push(event.data);\n            }\n          };\n          recording.recorder.onstart = () => __async(this, null, function* () {\n            recording.status = STATUS.RECORDING;\n            const updated = yield updateRecording(recording.id, recording);\n            resolve(updated);\n          });\n          recording.recorder.onerror = error => {\n            if (recordingId) {\n              const recording2 = getRecording(recordingId);\n              if (recording2) recording2.status = STATUS.ERROR;\n            }\n            handleError(\"startRecording\", error);\n          };\n          (_a3 = recording.recorder) == null ? void 0 : _a3.start(options == null ? void 0 : options.timeSlice);\n        }\n      });\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"startRecording\", error);\n    }\n  });\n  const pauseRecording = recordingId => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.pause();\n      if (((_b = recording.recorder) == null ? void 0 : _b.state) === \"paused\") {\n        recording.status = STATUS.PAUSED;\n        const updated = yield updateRecording(recording.id, recording);\n        return updated;\n      }\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"pauseRecording\", error);\n    }\n  });\n  const resumeRecording = recordingId => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.resume();\n      if (((_b = recording.recorder) == null ? void 0 : _b.state) === \"recording\") {\n        recording.status = STATUS.RECORDING;\n        const updated = yield updateRecording(recording.id, recording);\n        return updated;\n      }\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"resumeRecording\", error);\n    }\n  });\n  const stopRecording = recordingId => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.stop();\n      return yield new Promise(resolve => {\n        if (recording.recorder) {\n          recording.recorder.onstop = () => __async(this, null, function* () {\n            recording.status = STATUS.STOPPED;\n            const blob = new Blob(recording.blobChunks, {\n              type: recording.mimeType\n            });\n            const url = URL.createObjectURL(blob);\n            recording.blob = blob;\n            recording.objectURL = url;\n            if (recording.previewRef.current) {\n              recording.previewRef.current.src = url;\n            }\n            const updated = yield updateRecording(recording.id, recording);\n            resolve(updated);\n          });\n        }\n      });\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"stopRecording\", error);\n    }\n  });\n  const muteRecording = recordingId => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.stream.getAudioTracks().forEach(track => {\n        track.enabled = !track.enabled;\n      });\n      recording.isMuted = !recording.isMuted;\n      return yield updateRecording(recording.id, recording);\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"muteRecording\", error);\n    }\n  });\n  const cancelRecording = recordingId => __async(this, null, function* () {\n    var _a2, _b, _c;\n    try {\n      const recording = getRecording(recordingId);\n      const tracks = (_a2 = recording == null ? void 0 : recording.recorder) == null ? void 0 : _a2.stream.getTracks();\n      (_b = recording == null ? void 0 : recording.recorder) == null ? void 0 : _b.stop();\n      tracks == null ? void 0 : tracks.forEach(track => track.stop());\n      ((_c = recording.recorder) == null ? void 0 : _c.ondataavailable) && (recording.recorder.ondataavailable = null);\n      if (recording.webcamRef.current) {\n        const stream = recording.webcamRef.current.srcObject;\n        stream == null ? void 0 : stream.getTracks().forEach(track => track.stop());\n        recording.webcamRef.current.srcObject = null;\n        recording.webcamRef.current.load();\n      }\n      URL.revokeObjectURL(recording.objectURL);\n      yield deleteRecording(recording.id);\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"cancelRecording\", error);\n    }\n  });\n  const createRecording2 = (videoId, audioId) => __async(this, null, function* () {\n    var _a2, _b, _c, _d, _e, _f;\n    try {\n      const {\n        devicesById,\n        initialDevices\n      } = devices || {};\n      const videoLabel = videoId ? devicesById == null ? void 0 : devicesById[videoId].label : (_a2 = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _a2.label;\n      const audioLabel = audioId ? devicesById == null ? void 0 : devicesById[audioId].label : (_b = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _b.label;\n      const recordingId = `${videoId || ((_c = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _c.deviceId)}-${audioId || ((_d = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _d.deviceId)}`;\n      const isCreated = isRecordingCreated(recordingId);\n      if (isCreated) throw new Error(ERROR_MESSAGES.SESSION_EXISTS);\n      const recording = yield setRecording({\n        videoId: videoId || ((_e = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _e.deviceId),\n        audioId: audioId || ((_f = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _f.deviceId),\n        videoLabel,\n        audioLabel\n      });\n      return recording;\n    } catch (error) {\n      handleError(\"createRecording\", error);\n    }\n  });\n  const applyRecordingOptions = recordingId => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      if (options == null ? void 0 : options.fileName) {\n        recording.fileName = options.fileName;\n      }\n      if (options == null ? void 0 : options.fileType) {\n        recording.fileType = options.fileType;\n      }\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"applyRecordingOptions\", error);\n    }\n  });\n  const clearPreview = recordingId => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      if (recording.previewRef.current) recording.previewRef.current.src = \"\";\n      recording.status = STATUS.INITIAL;\n      URL.revokeObjectURL(recording.objectURL);\n      recording.blobChunks = [];\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"clearPreview\", error);\n    }\n  });\n  const download = recordingId => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      const downloadElement = document.createElement(\"a\");\n      if (recording == null ? void 0 : recording.objectURL) {\n        downloadElement.href = recording.objectURL;\n      }\n      downloadElement.download = `${recording.fileName}.${recording.fileType}`;\n      downloadElement.click();\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"download\", error);\n    }\n  });\n  return {\n    activeRecordings,\n    applyRecordingOptions,\n    clearAllRecordings,\n    clearPreview,\n    download,\n    cancelRecording,\n    createRecording: createRecording2,\n    muteRecording,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  };\n}\n\n// src/stream.ts\nfunction startStream(videoId, audioId, constraints) {\n  return __async(this, null, function* () {\n    const newStream = yield navigator.mediaDevices.getUserMedia({\n      video: {\n        deviceId: {\n          exact: videoId\n        }\n      },\n      audio: {\n        deviceId: {\n          exact: audioId\n        }\n      }\n    });\n    const tracks = newStream.getTracks();\n    tracks.forEach(track => track.applyConstraints(constraints));\n    return newStream;\n  });\n}\n\n// src/useCamera.ts\nvar DEFAULT_CONSTRAINTS = {\n  aspectRatio: 1.7,\n  echoCancellation: true,\n  height: 720,\n  width: 1280\n};\nfunction useCamera({\n  mediaTrackConstraints,\n  handleError\n}) {\n  const {\n    getRecording,\n    updateRecording\n  } = useRecordingStore();\n  const constraints = useMemo(() => __spreadValues(__spreadValues({}, DEFAULT_CONSTRAINTS), mediaTrackConstraints), [mediaTrackConstraints]);\n  const applyConstraints = (recordingId, constraints2) => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      if ((_a2 = recording.webcamRef.current) == null ? void 0 : _a2.srcObject) {\n        const stream = (_b = recording.webcamRef.current) == null ? void 0 : _b.srcObject;\n        const tracks = stream.getTracks() || [];\n        tracks == null ? void 0 : tracks.forEach(track => {\n          track.applyConstraints(__spreadValues({}, constraints2));\n        });\n      }\n      return recording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"applyConstraints\", error);\n    }\n  });\n  const openCamera = recordingId => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      const stream = yield startStream(recording.videoId, recording.audioId, constraints);\n      if (recording.webcamRef.current) {\n        recording.webcamRef.current.srcObject = stream;\n        yield recording.webcamRef.current.play();\n      }\n      recording.status = STATUS.OPEN;\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      handleError(\"openCamera\", error);\n    }\n  });\n  const closeCamera = recordingId => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      if (recording.webcamRef.current) {\n        const stream = recording.webcamRef.current.srcObject;\n        stream == null ? void 0 : stream.getTracks().forEach(track => track.stop());\n        ((_a2 = recording.recorder) == null ? void 0 : _a2.ondataavailable) && (recording.recorder.ondataavailable = null);\n        recording.webcamRef.current.srcObject = null;\n        recording.webcamRef.current.load();\n      }\n      recording.status = STATUS.CLOSED;\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"closeCamera\", error);\n    }\n  });\n  return {\n    applyConstraints,\n    closeCamera,\n    openCamera\n  };\n}\nfunction useRecordWebcam({\n  mediaRecorderOptions,\n  mediaTrackConstraints,\n  options\n} = {}) {\n  const [devices, setDevices] = useState();\n  const [errorMessage, setErrorMessage] = useState(null);\n  function handleError(functionName, error) {\n    const message = typeof error === \"string\" ? error : typeof error.message === \"string\" ? error.message : \"\";\n    setErrorMessage(message);\n  }\n  function clearError() {\n    setErrorMessage(null);\n  }\n  const {\n    applyConstraints,\n    closeCamera,\n    openCamera\n  } = useCamera({\n    mediaTrackConstraints,\n    handleError\n  });\n  const {\n    activeRecordings,\n    applyRecordingOptions,\n    cancelRecording,\n    clearAllRecordings,\n    clearPreview,\n    createRecording: createRecording2,\n    download,\n    muteRecording,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  } = useRecorder({\n    mediaRecorderOptions,\n    options,\n    devices,\n    handleError\n  });\n  function init() {\n    return __async(this, null, function* () {\n      try {\n        const devices2 = yield getDevices();\n        setDevices(devices2);\n      } catch (error) {\n        handleError(\"init\", error);\n      }\n    });\n  }\n  useEffect(() => {\n    init();\n    return () => {\n      clearAllRecordings();\n    };\n  }, []);\n  return {\n    activeRecordings,\n    applyConstraints,\n    applyRecordingOptions,\n    cancelRecording,\n    clearAllRecordings,\n    clearError,\n    clearPreview,\n    closeCamera,\n    createRecording: createRecording2,\n    devicesById: devices == null ? void 0 : devices.devicesById,\n    devicesByType: devices == null ? void 0 : devices.devicesByType,\n    download,\n    errorMessage,\n    muteRecording,\n    openCamera,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  };\n}\nexport { ERROR_MESSAGES, STATUS, checkAudioCodecPlaybackSupport, checkRecordingCodecSupport, checkVideoCodecPlaybackSupport, defaultCodec, getDevices, supportedAudioCodecs, supportedVideoCodecs, useRecordWebcam };","map":{"version":3,"names":["useState","useEffect","useMemo","useCallback","createRef","__defProp","Object","defineProperty","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","value","enumerable","configurable","writable","__spreadValues","a","b","prop","call","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","throw","x","done","then","apply","createStore","store2","stateUpdater","callbacks","Proxy","get","target","receiver","size","Reflect","Function","args","_a2","result","shouldTriggerUpdate","length","prev","useStore","forceUpdate","triggerUpdate","state","checkRecordingCodecSupport","codec","MediaRecorder","isTypeSupported","checkVideoCodecPlaybackSupport","video","document","createElement","canPlay","canPlayType","checkAudioCodecPlaybackSupport","audio","audioContainers","videoContainers","audioCodecs","videoCodecs","getSupportedMediaFormats","containers","codecs","type","reduce","acc","container","forEach","mimeType","push","supportedAudioCodecs","supportedVideoCodecs","videoContainer","videoCodec","_a","audioCodec","defaultCodec","ERROR_MESSAGES","CODEC_NOT_SUPPORTED","SESSION_EXISTS","NO_RECORDING_WITH_ID","NO_USER_PERMISSION","STATUS","INITIAL","CLOSED","OPEN","RECORDING","STOPPED","ERROR","PAUSED","createRecording","videoId","audioId","videoLabel","audioLabel","recordingId","recording","id","blobChunks","fileName","String","Date","getTime","fileType","isMuted","objectURL","previewRef","recorder","status","webcamRef","recordingMap","Map","store","useRecordingStore","activeRecordings","Array","from","values","clearAllRecordings","_a3","stream","current","srcObject","getTracks","track","stop","clear","isRecordingCreated","isCreated","Boolean","getRecording","Error","setRecording","params","newRecording","set","updateRecording","updatedValues","updatedRecording","deleteRecording","delete","byId","devices","deviceId","kind","label","byType","getUserPermission","navigator","mediaDevices","getUserMedia","enumerateDevices","error","getDevices","devicesByType","devicesById","initialDevices","window","DEFAULT_RECORDER_OPTIONS","audioBitsPerSecond","videoBitsPerSecond","useRecorder","mediaRecorderOptions","options","handleError","recorderOptions","startRecording","isCodecSupported","console","warn","ondataavailable","event","data","onstart","updated","onerror","recording2","start","timeSlice","pauseRecording","_b","pause","resumeRecording","resume","stopRecording","onstop","blob","Blob","url","URL","createObjectURL","src","muteRecording","getAudioTracks","enabled","cancelRecording","_c","tracks","load","revokeObjectURL","createRecording2","_d","_e","_f","applyRecordingOptions","clearPreview","download","downloadElement","href","click","startStream","constraints","newStream","exact","applyConstraints","DEFAULT_CONSTRAINTS","aspectRatio","echoCancellation","height","width","useCamera","mediaTrackConstraints","constraints2","openCamera","play","closeCamera","useRecordWebcam","setDevices","errorMessage","setErrorMessage","functionName","message","clearError","init","devices2"],"sources":["C:/AIQ_workspace/aiq/node_modules/react-record-webcam/dist/index.js"],"sourcesContent":["import { useState, useEffect, useMemo, useCallback, createRef } from 'react';\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nfunction createStore(store2) {\n  return (stateUpdater, callbacks) => {\n    return new Proxy(store2, {\n      get(target, prop, receiver) {\n        if (prop === \"size\") {\n          return target.size;\n        }\n        const value = Reflect.get(target, prop, receiver);\n        if (value instanceof Function) {\n          return function(...args) {\n            var _a2;\n            const result = value.apply(target, args);\n            const shouldTriggerUpdate = args[args.length - 1] === true;\n            if (shouldTriggerUpdate) {\n              stateUpdater((prev) => prev + 1);\n            }\n            if (prop === \"set\") {\n              return result.get(args[0]);\n            }\n            if (callbacks && callbacks[prop]) {\n              (_a2 = callbacks[prop]) == null ? void 0 : _a2.call(callbacks, result);\n            }\n            return result;\n          };\n        }\n        return value;\n      }\n    });\n  };\n}\nfunction useStore(store2, callbacks) {\n  const [, forceUpdate] = useState(0);\n  const triggerUpdate = useCallback(() => forceUpdate((prev) => prev + 1), []);\n  const state = useMemo(() => store2(triggerUpdate, callbacks), []);\n  return {\n    state\n  };\n}\n\n// src/codec.ts\nfunction checkRecordingCodecSupport(codec) {\n  if (typeof MediaRecorder === \"undefined\")\n    return false;\n  return MediaRecorder.isTypeSupported(codec);\n}\nfunction checkVideoCodecPlaybackSupport(codec) {\n  const video = document.createElement(\"video\");\n  const canPlay = video.canPlayType(codec);\n  return canPlay === \"maybe\" || canPlay === \"probably\" ? true : false;\n}\nfunction checkAudioCodecPlaybackSupport(codec) {\n  const audio = document.createElement(\"audio\");\n  const canPlay = audio.canPlayType(codec);\n  return canPlay === \"maybe\" || canPlay === \"probably\" ? true : false;\n}\nvar audioContainers = [\n  \"ogg\",\n  \"aac\",\n  \"flac\",\n  \"wav\",\n  \"mp4\"\n];\nvar videoContainers = [\n  \"webm\",\n  \"mp4\",\n  \"x-matroska\",\n  \"3gpp\",\n  \"3gpp2\",\n  \"3gp2\",\n  \"quicktime\",\n  \"mpeg\"\n];\nvar audioCodecs = [\"opus\", \"pcm\", \"aac\", \"mp4a\"];\nvar videoCodecs = [\n  \"vp9\",\n  \"vp8\",\n  \"avc1\",\n  \"av1\",\n  \"h265\",\n  \"h.264\",\n  \"h264\",\n  \"mpeg\"\n];\nfunction getSupportedMediaFormats(containers, codecs, type) {\n  return containers.reduce(\n    (acc, container) => {\n      codecs.forEach((codec) => {\n        const mimeType = `${type}/${container};codecs=${codec}`;\n        if (typeof MediaRecorder !== \"undefined\" && MediaRecorder.isTypeSupported(mimeType)) {\n          acc.mimeType.push(mimeType);\n          acc.codec.push(codec);\n          acc.container.push(container);\n        }\n      });\n      return acc;\n    },\n    { mimeType: [], codec: [], container: [] }\n  );\n}\nvar supportedAudioCodecs = getSupportedMediaFormats(\n  audioContainers,\n  audioCodecs,\n  \"audio\"\n);\nvar supportedVideoCodecs = getSupportedMediaFormats(\n  videoContainers,\n  videoCodecs,\n  \"video\"\n);\nvar videoContainer = supportedVideoCodecs.container[0];\nvar videoCodec = supportedVideoCodecs.codec[0];\nvar _a;\nvar audioCodec = (_a = supportedAudioCodecs == null ? void 0 : supportedAudioCodecs.codec) == null ? void 0 : _a[0];\nvar defaultCodec = `video/${videoContainer};codecs=${videoCodec}${audioCodec ? `,${audioCodec}` : \"\"}`;\n\n// src/useRecordingStore.ts\nvar ERROR_MESSAGES = {\n  CODEC_NOT_SUPPORTED: \"CODEC_NOT_SUPPORTED\",\n  SESSION_EXISTS: \"SESSION_EXISTS\",\n  NO_RECORDING_WITH_ID: \"NO_RECORDING_WITH_ID\",\n  NO_USER_PERMISSION: \"NO_USER_PERMISSION\"\n};\nvar STATUS = {\n  INITIAL: \"INITIAL\",\n  CLOSED: \"CLOSED\",\n  OPEN: \"OPEN\",\n  RECORDING: \"RECORDING\",\n  STOPPED: \"STOPPED\",\n  ERROR: \"ERROR\",\n  PAUSED: \"PAUSED\"\n};\nfunction createRecording({\n  videoId,\n  audioId,\n  videoLabel,\n  audioLabel\n}) {\n  const recordingId = `${videoId}-${audioId}`;\n  const recording = {\n    id: recordingId,\n    audioId,\n    audioLabel,\n    blobChunks: [],\n    fileName: String((/* @__PURE__ */ new Date()).getTime()),\n    fileType: \"webm\",\n    isMuted: false,\n    mimeType: defaultCodec,\n    objectURL: null,\n    previewRef: createRef(),\n    recorder: null,\n    status: STATUS.INITIAL,\n    videoId,\n    videoLabel,\n    webcamRef: createRef()\n  };\n  return recording;\n}\nvar recordingMap = /* @__PURE__ */ new Map();\nvar store = createStore(recordingMap);\nfunction useRecordingStore() {\n  var _a2;\n  const { state } = useStore(store);\n  const activeRecordings = Array.from((_a2 = recordingMap == null ? void 0 : recordingMap.values) == null ? void 0 : _a2.call(recordingMap));\n  const clearAllRecordings = () => __async(this, null, function* () {\n    Array.from(state.values()).forEach((recording) => {\n      var _a3;\n      const stream = (_a3 = recording.webcamRef.current) == null ? void 0 : _a3.srcObject;\n      if (stream) {\n        stream.getTracks().forEach((track) => track.stop());\n      }\n    });\n    state.clear(true);\n  });\n  const isRecordingCreated = (recordingId) => {\n    const isCreated = state.get(recordingId);\n    return Boolean(isCreated);\n  };\n  const getRecording = (recordingId) => {\n    const recording = state.get(recordingId);\n    if (!recording) {\n      throw new Error(ERROR_MESSAGES.NO_RECORDING_WITH_ID);\n    }\n    return recording;\n  };\n  const setRecording = (params) => __async(this, null, function* () {\n    const recording = createRecording(params);\n    const newRecording = state.set(recording.id, recording, true);\n    return newRecording;\n  });\n  const updateRecording = (recordingId, updatedValues) => __async(this, null, function* () {\n    const recording = state.get(recordingId);\n    const updatedRecording = state.set(\n      recordingId,\n      __spreadValues(__spreadValues({}, recording), updatedValues),\n      true\n    );\n    return updatedRecording;\n  });\n  const deleteRecording = (recordingId) => __async(this, null, function* () {\n    state.delete(recordingId, true);\n  });\n  return {\n    activeRecordings,\n    clearAllRecordings,\n    deleteRecording,\n    getRecording,\n    isRecordingCreated,\n    setRecording,\n    updateRecording\n  };\n}\n\n// src/devices.ts\nfunction byId(devices) {\n  return devices.reduce(\n    (result, { deviceId, kind, label }) => {\n      if (kind === \"videoinput\" || kind === \"audioinput\") {\n        result[deviceId] = {\n          label,\n          type: kind\n        };\n      }\n      return result;\n    },\n    {}\n  );\n}\nfunction byType(devices) {\n  return devices.reduce(\n    (result, { deviceId, kind, label }) => {\n      if (kind === \"videoinput\") {\n        result.video.push({ label, deviceId });\n      }\n      if (kind === \"audioinput\") {\n        result.audio.push({ label, deviceId });\n      }\n      return result;\n    },\n    {\n      video: [],\n      audio: []\n    }\n  );\n}\nfunction getUserPermission() {\n  return __async(this, null, function* () {\n    try {\n      const stream = yield navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: true\n      });\n      const mediaDevices = yield navigator.mediaDevices.enumerateDevices();\n      stream.getTracks().forEach((track) => {\n        track.stop();\n      });\n      return mediaDevices;\n    } catch (error) {\n      throw new Error(ERROR_MESSAGES.NO_USER_PERMISSION);\n    }\n  });\n}\nfunction getDevices() {\n  return __async(this, null, function* () {\n    let devicesByType = {\n      video: [],\n      audio: []\n    };\n    let devicesById = {};\n    let initialDevices = {\n      video: null,\n      audio: null\n    };\n    if (typeof window !== \"undefined\") {\n      const mediaDevices = yield getUserPermission();\n      devicesById = byId(mediaDevices);\n      devicesByType = byType(mediaDevices);\n      initialDevices = {\n        video: {\n          deviceId: devicesByType.video[0].deviceId,\n          label: devicesByType.video[0].label\n        },\n        audio: {\n          deviceId: devicesByType.audio[0].deviceId,\n          label: devicesByType.audio[0].label\n        }\n      };\n    }\n    return { devicesByType, devicesById, initialDevices };\n  });\n}\nvar DEFAULT_RECORDER_OPTIONS = {\n  audioBitsPerSecond: 128e3,\n  videoBitsPerSecond: 25e5,\n  mimeType: defaultCodec\n};\nfunction useRecorder({\n  mediaRecorderOptions,\n  options,\n  devices,\n  handleError\n}) {\n  const {\n    activeRecordings,\n    clearAllRecordings,\n    deleteRecording,\n    getRecording,\n    isRecordingCreated,\n    setRecording,\n    updateRecording\n  } = useRecordingStore();\n  const recorderOptions = useMemo(\n    () => __spreadValues(__spreadValues({}, DEFAULT_RECORDER_OPTIONS), mediaRecorderOptions),\n    [mediaRecorderOptions]\n  );\n  const startRecording = (recordingId) => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      const stream = (_a2 = recording.webcamRef.current) == null ? void 0 : _a2.srcObject;\n      recording.mimeType = recorderOptions.mimeType || recording.mimeType;\n      const isCodecSupported = MediaRecorder.isTypeSupported(\n        recording.mimeType\n      );\n      if (!isCodecSupported) {\n        console.warn(\"Codec not supported: \", recording.mimeType);\n        handleError(\"startRecording\", ERROR_MESSAGES.CODEC_NOT_SUPPORTED);\n      }\n      recording.recorder = new MediaRecorder(stream, recorderOptions);\n      return yield new Promise((resolve) => {\n        var _a3;\n        if (recording.recorder) {\n          recording.recorder.ondataavailable = (event) => {\n            if (event.data.size) {\n              recording.blobChunks.push(event.data);\n            }\n          };\n          recording.recorder.onstart = () => __async(this, null, function* () {\n            recording.status = STATUS.RECORDING;\n            const updated = yield updateRecording(recording.id, recording);\n            resolve(updated);\n          });\n          recording.recorder.onerror = (error) => {\n            if (recordingId) {\n              const recording2 = getRecording(recordingId);\n              if (recording2)\n                recording2.status = STATUS.ERROR;\n            }\n            handleError(\"startRecording\", error);\n          };\n          (_a3 = recording.recorder) == null ? void 0 : _a3.start(options == null ? void 0 : options.timeSlice);\n        }\n      });\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"startRecording\", error);\n    }\n  });\n  const pauseRecording = (recordingId) => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.pause();\n      if (((_b = recording.recorder) == null ? void 0 : _b.state) === \"paused\") {\n        recording.status = STATUS.PAUSED;\n        const updated = yield updateRecording(recording.id, recording);\n        return updated;\n      }\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"pauseRecording\", error);\n    }\n  });\n  const resumeRecording = (recordingId) => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.resume();\n      if (((_b = recording.recorder) == null ? void 0 : _b.state) === \"recording\") {\n        recording.status = STATUS.RECORDING;\n        const updated = yield updateRecording(recording.id, recording);\n        return updated;\n      }\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"resumeRecording\", error);\n    }\n  });\n  const stopRecording = (recordingId) => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.stop();\n      return yield new Promise((resolve) => {\n        if (recording.recorder) {\n          recording.recorder.onstop = () => __async(this, null, function* () {\n            recording.status = STATUS.STOPPED;\n            const blob = new Blob(recording.blobChunks, {\n              type: recording.mimeType\n            });\n            const url = URL.createObjectURL(blob);\n            recording.blob = blob;\n            recording.objectURL = url;\n            if (recording.previewRef.current) {\n              recording.previewRef.current.src = url;\n            }\n            const updated = yield updateRecording(recording.id, recording);\n            resolve(updated);\n          });\n        }\n      });\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"stopRecording\", error);\n    }\n  });\n  const muteRecording = (recordingId) => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.stream.getAudioTracks().forEach((track) => {\n        track.enabled = !track.enabled;\n      });\n      recording.isMuted = !recording.isMuted;\n      return yield updateRecording(recording.id, recording);\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"muteRecording\", error);\n    }\n  });\n  const cancelRecording = (recordingId) => __async(this, null, function* () {\n    var _a2, _b, _c;\n    try {\n      const recording = getRecording(recordingId);\n      const tracks = (_a2 = recording == null ? void 0 : recording.recorder) == null ? void 0 : _a2.stream.getTracks();\n      (_b = recording == null ? void 0 : recording.recorder) == null ? void 0 : _b.stop();\n      tracks == null ? void 0 : tracks.forEach((track) => track.stop());\n      ((_c = recording.recorder) == null ? void 0 : _c.ondataavailable) && (recording.recorder.ondataavailable = null);\n      if (recording.webcamRef.current) {\n        const stream = recording.webcamRef.current.srcObject;\n        stream == null ? void 0 : stream.getTracks().forEach((track) => track.stop());\n        recording.webcamRef.current.srcObject = null;\n        recording.webcamRef.current.load();\n      }\n      URL.revokeObjectURL(recording.objectURL);\n      yield deleteRecording(recording.id);\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"cancelRecording\", error);\n    }\n  });\n  const createRecording2 = (videoId, audioId) => __async(this, null, function* () {\n    var _a2, _b, _c, _d, _e, _f;\n    try {\n      const { devicesById, initialDevices } = devices || {};\n      const videoLabel = videoId ? devicesById == null ? void 0 : devicesById[videoId].label : (_a2 = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _a2.label;\n      const audioLabel = audioId ? devicesById == null ? void 0 : devicesById[audioId].label : (_b = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _b.label;\n      const recordingId = `${videoId || ((_c = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _c.deviceId)}-${audioId || ((_d = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _d.deviceId)}`;\n      const isCreated = isRecordingCreated(recordingId);\n      if (isCreated)\n        throw new Error(ERROR_MESSAGES.SESSION_EXISTS);\n      const recording = yield setRecording({\n        videoId: videoId || ((_e = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _e.deviceId),\n        audioId: audioId || ((_f = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _f.deviceId),\n        videoLabel,\n        audioLabel\n      });\n      return recording;\n    } catch (error) {\n      handleError(\"createRecording\", error);\n    }\n  });\n  const applyRecordingOptions = (recordingId) => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      if (options == null ? void 0 : options.fileName) {\n        recording.fileName = options.fileName;\n      }\n      if (options == null ? void 0 : options.fileType) {\n        recording.fileType = options.fileType;\n      }\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"applyRecordingOptions\", error);\n    }\n  });\n  const clearPreview = (recordingId) => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      if (recording.previewRef.current)\n        recording.previewRef.current.src = \"\";\n      recording.status = STATUS.INITIAL;\n      URL.revokeObjectURL(recording.objectURL);\n      recording.blobChunks = [];\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"clearPreview\", error);\n    }\n  });\n  const download = (recordingId) => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      const downloadElement = document.createElement(\"a\");\n      if (recording == null ? void 0 : recording.objectURL) {\n        downloadElement.href = recording.objectURL;\n      }\n      downloadElement.download = `${recording.fileName}.${recording.fileType}`;\n      downloadElement.click();\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"download\", error);\n    }\n  });\n  return {\n    activeRecordings,\n    applyRecordingOptions,\n    clearAllRecordings,\n    clearPreview,\n    download,\n    cancelRecording,\n    createRecording: createRecording2,\n    muteRecording,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  };\n}\n\n// src/stream.ts\nfunction startStream(videoId, audioId, constraints) {\n  return __async(this, null, function* () {\n    const newStream = yield navigator.mediaDevices.getUserMedia({\n      video: { deviceId: { exact: videoId } },\n      audio: {\n        deviceId: { exact: audioId }\n      }\n    });\n    const tracks = newStream.getTracks();\n    tracks.forEach((track) => track.applyConstraints(constraints));\n    return newStream;\n  });\n}\n\n// src/useCamera.ts\nvar DEFAULT_CONSTRAINTS = {\n  aspectRatio: 1.7,\n  echoCancellation: true,\n  height: 720,\n  width: 1280\n};\nfunction useCamera({\n  mediaTrackConstraints,\n  handleError\n}) {\n  const { getRecording, updateRecording } = useRecordingStore();\n  const constraints = useMemo(\n    () => __spreadValues(__spreadValues({}, DEFAULT_CONSTRAINTS), mediaTrackConstraints),\n    [mediaTrackConstraints]\n  );\n  const applyConstraints = (recordingId, constraints2) => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      if ((_a2 = recording.webcamRef.current) == null ? void 0 : _a2.srcObject) {\n        const stream = (_b = recording.webcamRef.current) == null ? void 0 : _b.srcObject;\n        const tracks = stream.getTracks() || [];\n        tracks == null ? void 0 : tracks.forEach((track) => {\n          track.applyConstraints(__spreadValues({}, constraints2));\n        });\n      }\n      return recording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"applyConstraints\", error);\n    }\n  });\n  const openCamera = (recordingId) => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      const stream = yield startStream(\n        recording.videoId,\n        recording.audioId,\n        constraints\n      );\n      if (recording.webcamRef.current) {\n        recording.webcamRef.current.srcObject = stream;\n        yield recording.webcamRef.current.play();\n      }\n      recording.status = STATUS.OPEN;\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      handleError(\"openCamera\", error);\n    }\n  });\n  const closeCamera = (recordingId) => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      if (recording.webcamRef.current) {\n        const stream = recording.webcamRef.current.srcObject;\n        stream == null ? void 0 : stream.getTracks().forEach((track) => track.stop());\n        ((_a2 = recording.recorder) == null ? void 0 : _a2.ondataavailable) && (recording.recorder.ondataavailable = null);\n        recording.webcamRef.current.srcObject = null;\n        recording.webcamRef.current.load();\n      }\n      recording.status = STATUS.CLOSED;\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"closeCamera\", error);\n    }\n  });\n  return {\n    applyConstraints,\n    closeCamera,\n    openCamera\n  };\n}\nfunction useRecordWebcam({\n  mediaRecorderOptions,\n  mediaTrackConstraints,\n  options\n} = {}) {\n  const [devices, setDevices] = useState();\n  const [errorMessage, setErrorMessage] = useState(null);\n  function handleError(functionName, error) {\n    const message = typeof error === \"string\" ? error : typeof error.message === \"string\" ? error.message : \"\";\n    setErrorMessage(message);\n  }\n  function clearError() {\n    setErrorMessage(null);\n  }\n  const { applyConstraints, closeCamera, openCamera } = useCamera({\n    mediaTrackConstraints,\n    handleError\n  });\n  const {\n    activeRecordings,\n    applyRecordingOptions,\n    cancelRecording,\n    clearAllRecordings,\n    clearPreview,\n    createRecording: createRecording2,\n    download,\n    muteRecording,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  } = useRecorder({ mediaRecorderOptions, options, devices, handleError });\n  function init() {\n    return __async(this, null, function* () {\n      try {\n        const devices2 = yield getDevices();\n        setDevices(devices2);\n      } catch (error) {\n        handleError(\"init\", error);\n      }\n    });\n  }\n  useEffect(() => {\n    init();\n    return () => {\n      clearAllRecordings();\n    };\n  }, []);\n  return {\n    activeRecordings,\n    applyConstraints,\n    applyRecordingOptions,\n    cancelRecording,\n    clearAllRecordings,\n    clearError,\n    clearPreview,\n    closeCamera,\n    createRecording: createRecording2,\n    devicesById: devices == null ? void 0 : devices.devicesById,\n    devicesByType: devices == null ? void 0 : devices.devicesByType,\n    download,\n    errorMessage,\n    muteRecording,\n    openCamera,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  };\n}\n\nexport { ERROR_MESSAGES, STATUS, checkAudioCodecPlaybackSupport, checkRecordingCodecSupport, checkVideoCodecPlaybackSupport, defaultCodec, getDevices, supportedAudioCodecs, supportedVideoCodecs, useRecordWebcam };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}