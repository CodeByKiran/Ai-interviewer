{"ast":null,"code":"import { useState, useEffect, useMemo, useCallback, createRef } from 'react';\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {})) if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)) {\n    if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n  }\n  return a;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = value => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = value => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = x => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nfunction createStore(store2) {\n  return (stateUpdater, callbacks) => {\n    return new Proxy(store2, {\n      get(target, prop, receiver) {\n        if (prop === \"size\") {\n          return target.size;\n        }\n        const value = Reflect.get(target, prop, receiver);\n        if (value instanceof Function) {\n          return function () {\n            var _a2;\n            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n              args[_key] = arguments[_key];\n            }\n            const result = value.apply(target, args);\n            const shouldTriggerUpdate = args[args.length - 1] === true;\n            if (shouldTriggerUpdate) {\n              stateUpdater(prev => prev + 1);\n            }\n            if (prop === \"set\") {\n              return result.get(args[0]);\n            }\n            if (callbacks && callbacks[prop]) {\n              (_a2 = callbacks[prop]) == null ? void 0 : _a2.call(callbacks, result);\n            }\n            return result;\n          };\n        }\n        return value;\n      }\n    });\n  };\n}\nfunction useStore(store2, callbacks) {\n  const [, forceUpdate] = useState(0);\n  const triggerUpdate = useCallback(() => forceUpdate(prev => prev + 1), []);\n  const state = useMemo(() => store2(triggerUpdate, callbacks), []);\n  return {\n    state\n  };\n}\n\n// src/codec.ts\nfunction checkRecordingCodecSupport(codec) {\n  if (typeof MediaRecorder === \"undefined\") return false;\n  return MediaRecorder.isTypeSupported(codec);\n}\nfunction checkVideoCodecPlaybackSupport(codec) {\n  const video = document.createElement(\"video\");\n  const canPlay = video.canPlayType(codec);\n  return canPlay === \"maybe\" || canPlay === \"probably\" ? true : false;\n}\nfunction checkAudioCodecPlaybackSupport(codec) {\n  const audio = document.createElement(\"audio\");\n  const canPlay = audio.canPlayType(codec);\n  return canPlay === \"maybe\" || canPlay === \"probably\" ? true : false;\n}\nvar audioContainers = [\"ogg\", \"aac\", \"flac\", \"wav\", \"mp4\"];\nvar videoContainers = [\"webm\", \"mp4\", \"x-matroska\", \"3gpp\", \"3gpp2\", \"3gp2\", \"quicktime\", \"mpeg\"];\nvar audioCodecs = [\"opus\", \"pcm\", \"aac\", \"mp4a\"];\nvar videoCodecs = [\"vp9\", \"vp8\", \"avc1\", \"av1\", \"h265\", \"h.264\", \"h264\", \"mpeg\"];\nfunction getSupportedMediaFormats(containers, codecs, type) {\n  return containers.reduce((acc, container) => {\n    codecs.forEach(codec => {\n      const mimeType = `${type}/${container};codecs=${codec}`;\n      if (typeof MediaRecorder !== \"undefined\" && MediaRecorder.isTypeSupported(mimeType)) {\n        acc.mimeType.push(mimeType);\n        acc.codec.push(codec);\n        acc.container.push(container);\n      }\n    });\n    return acc;\n  }, {\n    mimeType: [],\n    codec: [],\n    container: []\n  });\n}\nvar supportedAudioCodecs = getSupportedMediaFormats(audioContainers, audioCodecs, \"audio\");\nvar supportedVideoCodecs = getSupportedMediaFormats(videoContainers, videoCodecs, \"video\");\nvar videoContainer = supportedVideoCodecs.container[0];\nvar videoCodec = supportedVideoCodecs.codec[0];\nvar _a;\nvar audioCodec = (_a = supportedAudioCodecs == null ? void 0 : supportedAudioCodecs.codec) == null ? void 0 : _a[0];\nvar defaultCodec = `video/${videoContainer};codecs=${videoCodec}${audioCodec ? `,${audioCodec}` : \"\"}`;\n\n// src/useRecordingStore.ts\nvar ERROR_MESSAGES = {\n  CODEC_NOT_SUPPORTED: \"CODEC_NOT_SUPPORTED\",\n  SESSION_EXISTS: \"SESSION_EXISTS\",\n  NO_RECORDING_WITH_ID: \"NO_RECORDING_WITH_ID\",\n  NO_USER_PERMISSION: \"NO_USER_PERMISSION\"\n};\nvar STATUS = {\n  INITIAL: \"INITIAL\",\n  CLOSED: \"CLOSED\",\n  OPEN: \"OPEN\",\n  RECORDING: \"RECORDING\",\n  STOPPED: \"STOPPED\",\n  ERROR: \"ERROR\",\n  PAUSED: \"PAUSED\"\n};\nfunction createRecording(_ref) {\n  let {\n    videoId,\n    audioId,\n    videoLabel,\n    audioLabel\n  } = _ref;\n  const recordingId = `${videoId}-${audioId}`;\n  const recording = {\n    id: recordingId,\n    audioId,\n    audioLabel,\n    blobChunks: [],\n    fileName: String((/* @__PURE__ */new Date()).getTime()),\n    fileType: \"webm\",\n    isMuted: false,\n    mimeType: defaultCodec,\n    objectURL: null,\n    previewRef: createRef(),\n    recorder: null,\n    status: STATUS.INITIAL,\n    videoId,\n    videoLabel,\n    webcamRef: createRef()\n  };\n  return recording;\n}\nvar recordingMap = /* @__PURE__ */new Map();\nvar store = createStore(recordingMap);\nfunction useRecordingStore() {\n  var _a2;\n  const {\n    state\n  } = useStore(store);\n  const activeRecordings = Array.from((_a2 = recordingMap == null ? void 0 : recordingMap.values) == null ? void 0 : _a2.call(recordingMap));\n  const clearAllRecordings = () => __async(this, null, function* () {\n    Array.from(state.values()).forEach(recording => {\n      var _a3;\n      const stream = (_a3 = recording.webcamRef.current) == null ? void 0 : _a3.srcObject;\n      if (stream) {\n        stream.getTracks().forEach(track => track.stop());\n      }\n    });\n    state.clear(true);\n  });\n  const isRecordingCreated = recordingId => {\n    const isCreated = state.get(recordingId);\n    return Boolean(isCreated);\n  };\n  const getRecording = recordingId => {\n    const recording = state.get(recordingId);\n    if (!recording) {\n      throw new Error(ERROR_MESSAGES.NO_RECORDING_WITH_ID);\n    }\n    return recording;\n  };\n  const setRecording = params => __async(this, null, function* () {\n    const recording = createRecording(params);\n    const newRecording = state.set(recording.id, recording, true);\n    return newRecording;\n  });\n  const updateRecording = (recordingId, updatedValues) => __async(this, null, function* () {\n    const recording = state.get(recordingId);\n    const updatedRecording = state.set(recordingId, __spreadValues(__spreadValues({}, recording), updatedValues), true);\n    return updatedRecording;\n  });\n  const deleteRecording = recordingId => __async(this, null, function* () {\n    state.delete(recordingId, true);\n  });\n  return {\n    activeRecordings,\n    clearAllRecordings,\n    deleteRecording,\n    getRecording,\n    isRecordingCreated,\n    setRecording,\n    updateRecording\n  };\n}\n\n// src/devices.ts\nfunction byId(devices) {\n  return devices.reduce((result, _ref2) => {\n    let {\n      deviceId,\n      kind,\n      label\n    } = _ref2;\n    if (kind === \"videoinput\" || kind === \"audioinput\") {\n      result[deviceId] = {\n        label,\n        type: kind\n      };\n    }\n    return result;\n  }, {});\n}\nfunction byType(devices) {\n  return devices.reduce((result, _ref3) => {\n    let {\n      deviceId,\n      kind,\n      label\n    } = _ref3;\n    if (kind === \"videoinput\") {\n      result.video.push({\n        label,\n        deviceId\n      });\n    }\n    if (kind === \"audioinput\") {\n      result.audio.push({\n        label,\n        deviceId\n      });\n    }\n    return result;\n  }, {\n    video: [],\n    audio: []\n  });\n}\nfunction getUserPermission() {\n  return __async(this, null, function* () {\n    try {\n      const stream = yield navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: true\n      });\n      const mediaDevices = yield navigator.mediaDevices.enumerateDevices();\n      stream.getTracks().forEach(track => {\n        track.stop();\n      });\n      return mediaDevices;\n    } catch (error) {\n      throw new Error(ERROR_MESSAGES.NO_USER_PERMISSION);\n    }\n  });\n}\nfunction getDevices() {\n  return __async(this, null, function* () {\n    let devicesByType = {\n      video: [],\n      audio: []\n    };\n    let devicesById = {};\n    let initialDevices = {\n      video: null,\n      audio: null\n    };\n    if (typeof window !== \"undefined\") {\n      const mediaDevices = yield getUserPermission();\n      devicesById = byId(mediaDevices);\n      devicesByType = byType(mediaDevices);\n      initialDevices = {\n        video: {\n          deviceId: devicesByType.video[0].deviceId,\n          label: devicesByType.video[0].label\n        },\n        audio: {\n          deviceId: devicesByType.audio[0].deviceId,\n          label: devicesByType.audio[0].label\n        }\n      };\n    }\n    return {\n      devicesByType,\n      devicesById,\n      initialDevices\n    };\n  });\n}\nvar DEFAULT_RECORDER_OPTIONS = {\n  audioBitsPerSecond: 128e3,\n  videoBitsPerSecond: 25e5,\n  mimeType: defaultCodec\n};\nfunction useRecorder(_ref4) {\n  let {\n    mediaRecorderOptions,\n    options,\n    devices,\n    handleError\n  } = _ref4;\n  const {\n    activeRecordings,\n    clearAllRecordings,\n    deleteRecording,\n    getRecording,\n    isRecordingCreated,\n    setRecording,\n    updateRecording\n  } = useRecordingStore();\n  const recorderOptions = useMemo(() => __spreadValues(__spreadValues({}, DEFAULT_RECORDER_OPTIONS), mediaRecorderOptions), [mediaRecorderOptions]);\n  const startRecording = recordingId => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      const stream = (_a2 = recording.webcamRef.current) == null ? void 0 : _a2.srcObject;\n      recording.mimeType = recorderOptions.mimeType || recording.mimeType;\n      const isCodecSupported = MediaRecorder.isTypeSupported(recording.mimeType);\n      if (!isCodecSupported) {\n        console.warn(\"Codec not supported: \", recording.mimeType);\n        handleError(\"startRecording\", ERROR_MESSAGES.CODEC_NOT_SUPPORTED);\n      }\n      recording.recorder = new MediaRecorder(stream, recorderOptions);\n      return yield new Promise(resolve => {\n        var _a3;\n        if (recording.recorder) {\n          recording.recorder.ondataavailable = event => {\n            if (event.data.size) {\n              recording.blobChunks.push(event.data);\n            }\n          };\n          recording.recorder.onstart = () => __async(this, null, function* () {\n            recording.status = STATUS.RECORDING;\n            const updated = yield updateRecording(recording.id, recording);\n            resolve(updated);\n          });\n          recording.recorder.onerror = error => {\n            if (recordingId) {\n              const recording2 = getRecording(recordingId);\n              if (recording2) recording2.status = STATUS.ERROR;\n            }\n            handleError(\"startRecording\", error);\n          };\n          (_a3 = recording.recorder) == null ? void 0 : _a3.start(options == null ? void 0 : options.timeSlice);\n        }\n      });\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"startRecording\", error);\n    }\n  });\n  const pauseRecording = recordingId => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.pause();\n      if (((_b = recording.recorder) == null ? void 0 : _b.state) === \"paused\") {\n        recording.status = STATUS.PAUSED;\n        const updated = yield updateRecording(recording.id, recording);\n        return updated;\n      }\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"pauseRecording\", error);\n    }\n  });\n  const resumeRecording = recordingId => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.resume();\n      if (((_b = recording.recorder) == null ? void 0 : _b.state) === \"recording\") {\n        recording.status = STATUS.RECORDING;\n        const updated = yield updateRecording(recording.id, recording);\n        return updated;\n      }\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"resumeRecording\", error);\n    }\n  });\n  const stopRecording = recordingId => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.stop();\n      return yield new Promise(resolve => {\n        if (recording.recorder) {\n          recording.recorder.onstop = () => __async(this, null, function* () {\n            recording.status = STATUS.STOPPED;\n            const blob = new Blob(recording.blobChunks, {\n              type: recording.mimeType\n            });\n            const url = URL.createObjectURL(blob);\n            recording.blob = blob;\n            recording.objectURL = url;\n            if (recording.previewRef.current) {\n              recording.previewRef.current.src = url;\n            }\n            const updated = yield updateRecording(recording.id, recording);\n            resolve(updated);\n          });\n        }\n      });\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"stopRecording\", error);\n    }\n  });\n  const muteRecording = recordingId => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.stream.getAudioTracks().forEach(track => {\n        track.enabled = !track.enabled;\n      });\n      recording.isMuted = !recording.isMuted;\n      return yield updateRecording(recording.id, recording);\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"muteRecording\", error);\n    }\n  });\n  const cancelRecording = recordingId => __async(this, null, function* () {\n    var _a2, _b, _c;\n    try {\n      const recording = getRecording(recordingId);\n      const tracks = (_a2 = recording == null ? void 0 : recording.recorder) == null ? void 0 : _a2.stream.getTracks();\n      (_b = recording == null ? void 0 : recording.recorder) == null ? void 0 : _b.stop();\n      tracks == null ? void 0 : tracks.forEach(track => track.stop());\n      ((_c = recording.recorder) == null ? void 0 : _c.ondataavailable) && (recording.recorder.ondataavailable = null);\n      if (recording.webcamRef.current) {\n        const stream = recording.webcamRef.current.srcObject;\n        stream == null ? void 0 : stream.getTracks().forEach(track => track.stop());\n        recording.webcamRef.current.srcObject = null;\n        recording.webcamRef.current.load();\n      }\n      URL.revokeObjectURL(recording.objectURL);\n      yield deleteRecording(recording.id);\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"cancelRecording\", error);\n    }\n  });\n  const createRecording2 = (videoId, audioId) => __async(this, null, function* () {\n    var _a2, _b, _c, _d, _e, _f;\n    try {\n      const {\n        devicesById,\n        initialDevices\n      } = devices || {};\n      const videoLabel = videoId ? devicesById == null ? void 0 : devicesById[videoId].label : (_a2 = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _a2.label;\n      const audioLabel = audioId ? devicesById == null ? void 0 : devicesById[audioId].label : (_b = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _b.label;\n      const recordingId = `${videoId || ((_c = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _c.deviceId)}-${audioId || ((_d = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _d.deviceId)}`;\n      const isCreated = isRecordingCreated(recordingId);\n      if (isCreated) throw new Error(ERROR_MESSAGES.SESSION_EXISTS);\n      const recording = yield setRecording({\n        videoId: videoId || ((_e = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _e.deviceId),\n        audioId: audioId || ((_f = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _f.deviceId),\n        videoLabel,\n        audioLabel\n      });\n      return recording;\n    } catch (error) {\n      handleError(\"createRecording\", error);\n    }\n  });\n  const applyRecordingOptions = recordingId => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      if (options == null ? void 0 : options.fileName) {\n        recording.fileName = options.fileName;\n      }\n      if (options == null ? void 0 : options.fileType) {\n        recording.fileType = options.fileType;\n      }\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"applyRecordingOptions\", error);\n    }\n  });\n  const clearPreview = recordingId => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      if (recording.previewRef.current) recording.previewRef.current.src = \"\";\n      recording.status = STATUS.INITIAL;\n      URL.revokeObjectURL(recording.objectURL);\n      recording.blobChunks = [];\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"clearPreview\", error);\n    }\n  });\n  const download = recordingId => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      const downloadElement = document.createElement(\"a\");\n      if (recording == null ? void 0 : recording.objectURL) {\n        downloadElement.href = recording.objectURL;\n      }\n      downloadElement.download = `${recording.fileName}.${recording.fileType}`;\n      downloadElement.click();\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"download\", error);\n    }\n  });\n  return {\n    activeRecordings,\n    applyRecordingOptions,\n    clearAllRecordings,\n    clearPreview,\n    download,\n    cancelRecording,\n    createRecording: createRecording2,\n    muteRecording,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  };\n}\n\n// src/stream.ts\nfunction startStream(videoId, audioId, constraints) {\n  return __async(this, null, function* () {\n    const newStream = yield navigator.mediaDevices.getUserMedia({\n      video: {\n        deviceId: {\n          exact: videoId\n        }\n      },\n      audio: {\n        deviceId: {\n          exact: audioId\n        }\n      }\n    });\n    const tracks = newStream.getTracks();\n    tracks.forEach(track => track.applyConstraints(constraints));\n    return newStream;\n  });\n}\n\n// src/useCamera.ts\nvar DEFAULT_CONSTRAINTS = {\n  aspectRatio: 1.7,\n  echoCancellation: true,\n  height: 720,\n  width: 1280\n};\nfunction useCamera(_ref5) {\n  let {\n    mediaTrackConstraints,\n    handleError\n  } = _ref5;\n  const {\n    getRecording,\n    updateRecording\n  } = useRecordingStore();\n  const constraints = useMemo(() => __spreadValues(__spreadValues({}, DEFAULT_CONSTRAINTS), mediaTrackConstraints), [mediaTrackConstraints]);\n  const applyConstraints = (recordingId, constraints2) => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      if ((_a2 = recording.webcamRef.current) == null ? void 0 : _a2.srcObject) {\n        const stream = (_b = recording.webcamRef.current) == null ? void 0 : _b.srcObject;\n        const tracks = stream.getTracks() || [];\n        tracks == null ? void 0 : tracks.forEach(track => {\n          track.applyConstraints(__spreadValues({}, constraints2));\n        });\n      }\n      return recording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"applyConstraints\", error);\n    }\n  });\n  const openCamera = recordingId => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      const stream = yield startStream(recording.videoId, recording.audioId, constraints);\n      if (recording.webcamRef.current) {\n        recording.webcamRef.current.srcObject = stream;\n        yield recording.webcamRef.current.play();\n      }\n      recording.status = STATUS.OPEN;\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      handleError(\"openCamera\", error);\n    }\n  });\n  const closeCamera = recordingId => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      if (recording.webcamRef.current) {\n        const stream = recording.webcamRef.current.srcObject;\n        stream == null ? void 0 : stream.getTracks().forEach(track => track.stop());\n        ((_a2 = recording.recorder) == null ? void 0 : _a2.ondataavailable) && (recording.recorder.ondataavailable = null);\n        recording.webcamRef.current.srcObject = null;\n        recording.webcamRef.current.load();\n      }\n      recording.status = STATUS.CLOSED;\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording) recording.status = STATUS.ERROR;\n      }\n      handleError(\"closeCamera\", error);\n    }\n  });\n  return {\n    applyConstraints,\n    closeCamera,\n    openCamera\n  };\n}\nfunction useRecordWebcam() {\n  let {\n    mediaRecorderOptions,\n    mediaTrackConstraints,\n    options\n  } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const [devices, setDevices] = useState();\n  const [errorMessage, setErrorMessage] = useState(null);\n  function handleError(functionName, error) {\n    const message = typeof error === \"string\" ? error : typeof error.message === \"string\" ? error.message : \"\";\n    setErrorMessage(message);\n  }\n  function clearError() {\n    setErrorMessage(null);\n  }\n  const {\n    applyConstraints,\n    closeCamera,\n    openCamera\n  } = useCamera({\n    mediaTrackConstraints,\n    handleError\n  });\n  const {\n    activeRecordings,\n    applyRecordingOptions,\n    cancelRecording,\n    clearAllRecordings,\n    clearPreview,\n    createRecording: createRecording2,\n    download,\n    muteRecording,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  } = useRecorder({\n    mediaRecorderOptions,\n    options,\n    devices,\n    handleError\n  });\n  function init() {\n    return __async(this, null, function* () {\n      try {\n        const devices2 = yield getDevices();\n        setDevices(devices2);\n      } catch (error) {\n        handleError(\"init\", error);\n      }\n    });\n  }\n  useEffect(() => {\n    init();\n    return () => {\n      clearAllRecordings();\n    };\n  }, []);\n  return {\n    activeRecordings,\n    applyConstraints,\n    applyRecordingOptions,\n    cancelRecording,\n    clearAllRecordings,\n    clearError,\n    clearPreview,\n    closeCamera,\n    createRecording: createRecording2,\n    devicesById: devices == null ? void 0 : devices.devicesById,\n    devicesByType: devices == null ? void 0 : devices.devicesByType,\n    download,\n    errorMessage,\n    muteRecording,\n    openCamera,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  };\n}\nexport { ERROR_MESSAGES, STATUS, checkAudioCodecPlaybackSupport, checkRecordingCodecSupport, checkVideoCodecPlaybackSupport, defaultCodec, getDevices, supportedAudioCodecs, supportedVideoCodecs, useRecordWebcam };","map":{"version":3,"names":["useState","useEffect","useMemo","useCallback","createRef","__defProp","Object","defineProperty","__getOwnPropSymbols","getOwnPropertySymbols","__hasOwnProp","prototype","hasOwnProperty","__propIsEnum","propertyIsEnumerable","__defNormalProp","obj","key","value","enumerable","configurable","writable","__spreadValues","a","b","prop","call","__async","__this","__arguments","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","throw","x","done","then","apply","createStore","store2","stateUpdater","callbacks","Proxy","get","target","receiver","size","Reflect","Function","_a2","_len","arguments","length","args","Array","_key","result","shouldTriggerUpdate","prev","useStore","forceUpdate","triggerUpdate","state","checkRecordingCodecSupport","codec","MediaRecorder","isTypeSupported","checkVideoCodecPlaybackSupport","video","document","createElement","canPlay","canPlayType","checkAudioCodecPlaybackSupport","audio","audioContainers","videoContainers","audioCodecs","videoCodecs","getSupportedMediaFormats","containers","codecs","type","reduce","acc","container","forEach","mimeType","push","supportedAudioCodecs","supportedVideoCodecs","videoContainer","videoCodec","_a","audioCodec","defaultCodec","ERROR_MESSAGES","CODEC_NOT_SUPPORTED","SESSION_EXISTS","NO_RECORDING_WITH_ID","NO_USER_PERMISSION","STATUS","INITIAL","CLOSED","OPEN","RECORDING","STOPPED","ERROR","PAUSED","createRecording","_ref","videoId","audioId","videoLabel","audioLabel","recordingId","recording","id","blobChunks","fileName","String","Date","getTime","fileType","isMuted","objectURL","previewRef","recorder","status","webcamRef","recordingMap","Map","store","useRecordingStore","activeRecordings","from","values","clearAllRecordings","_a3","stream","current","srcObject","getTracks","track","stop","clear","isRecordingCreated","isCreated","Boolean","getRecording","Error","setRecording","params","newRecording","set","updateRecording","updatedValues","updatedRecording","deleteRecording","delete","byId","devices","_ref2","deviceId","kind","label","byType","_ref3","getUserPermission","navigator","mediaDevices","getUserMedia","enumerateDevices","error","getDevices","devicesByType","devicesById","initialDevices","window","DEFAULT_RECORDER_OPTIONS","audioBitsPerSecond","videoBitsPerSecond","useRecorder","_ref4","mediaRecorderOptions","options","handleError","recorderOptions","startRecording","isCodecSupported","console","warn","ondataavailable","event","data","onstart","updated","onerror","recording2","start","timeSlice","pauseRecording","_b","pause","resumeRecording","resume","stopRecording","onstop","blob","Blob","url","URL","createObjectURL","src","muteRecording","getAudioTracks","enabled","cancelRecording","_c","tracks","load","revokeObjectURL","createRecording2","_d","_e","_f","applyRecordingOptions","clearPreview","download","downloadElement","href","click","startStream","constraints","newStream","exact","applyConstraints","DEFAULT_CONSTRAINTS","aspectRatio","echoCancellation","height","width","useCamera","_ref5","mediaTrackConstraints","constraints2","openCamera","play","closeCamera","useRecordWebcam","undefined","setDevices","errorMessage","setErrorMessage","functionName","message","clearError","init","devices2"],"sources":["C:/AIQ_workspace/aiq/node_modules/react-record-webcam/dist/index.js"],"sourcesContent":["import { useState, useEffect, useMemo, useCallback, createRef } from 'react';\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __async = (__this, __arguments, generator) => {\n  return new Promise((resolve, reject) => {\n    var fulfilled = (value) => {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var rejected = (value) => {\n      try {\n        step(generator.throw(value));\n      } catch (e) {\n        reject(e);\n      }\n    };\n    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);\n    step((generator = generator.apply(__this, __arguments)).next());\n  });\n};\nfunction createStore(store2) {\n  return (stateUpdater, callbacks) => {\n    return new Proxy(store2, {\n      get(target, prop, receiver) {\n        if (prop === \"size\") {\n          return target.size;\n        }\n        const value = Reflect.get(target, prop, receiver);\n        if (value instanceof Function) {\n          return function(...args) {\n            var _a2;\n            const result = value.apply(target, args);\n            const shouldTriggerUpdate = args[args.length - 1] === true;\n            if (shouldTriggerUpdate) {\n              stateUpdater((prev) => prev + 1);\n            }\n            if (prop === \"set\") {\n              return result.get(args[0]);\n            }\n            if (callbacks && callbacks[prop]) {\n              (_a2 = callbacks[prop]) == null ? void 0 : _a2.call(callbacks, result);\n            }\n            return result;\n          };\n        }\n        return value;\n      }\n    });\n  };\n}\nfunction useStore(store2, callbacks) {\n  const [, forceUpdate] = useState(0);\n  const triggerUpdate = useCallback(() => forceUpdate((prev) => prev + 1), []);\n  const state = useMemo(() => store2(triggerUpdate, callbacks), []);\n  return {\n    state\n  };\n}\n\n// src/codec.ts\nfunction checkRecordingCodecSupport(codec) {\n  if (typeof MediaRecorder === \"undefined\")\n    return false;\n  return MediaRecorder.isTypeSupported(codec);\n}\nfunction checkVideoCodecPlaybackSupport(codec) {\n  const video = document.createElement(\"video\");\n  const canPlay = video.canPlayType(codec);\n  return canPlay === \"maybe\" || canPlay === \"probably\" ? true : false;\n}\nfunction checkAudioCodecPlaybackSupport(codec) {\n  const audio = document.createElement(\"audio\");\n  const canPlay = audio.canPlayType(codec);\n  return canPlay === \"maybe\" || canPlay === \"probably\" ? true : false;\n}\nvar audioContainers = [\n  \"ogg\",\n  \"aac\",\n  \"flac\",\n  \"wav\",\n  \"mp4\"\n];\nvar videoContainers = [\n  \"webm\",\n  \"mp4\",\n  \"x-matroska\",\n  \"3gpp\",\n  \"3gpp2\",\n  \"3gp2\",\n  \"quicktime\",\n  \"mpeg\"\n];\nvar audioCodecs = [\"opus\", \"pcm\", \"aac\", \"mp4a\"];\nvar videoCodecs = [\n  \"vp9\",\n  \"vp8\",\n  \"avc1\",\n  \"av1\",\n  \"h265\",\n  \"h.264\",\n  \"h264\",\n  \"mpeg\"\n];\nfunction getSupportedMediaFormats(containers, codecs, type) {\n  return containers.reduce(\n    (acc, container) => {\n      codecs.forEach((codec) => {\n        const mimeType = `${type}/${container};codecs=${codec}`;\n        if (typeof MediaRecorder !== \"undefined\" && MediaRecorder.isTypeSupported(mimeType)) {\n          acc.mimeType.push(mimeType);\n          acc.codec.push(codec);\n          acc.container.push(container);\n        }\n      });\n      return acc;\n    },\n    { mimeType: [], codec: [], container: [] }\n  );\n}\nvar supportedAudioCodecs = getSupportedMediaFormats(\n  audioContainers,\n  audioCodecs,\n  \"audio\"\n);\nvar supportedVideoCodecs = getSupportedMediaFormats(\n  videoContainers,\n  videoCodecs,\n  \"video\"\n);\nvar videoContainer = supportedVideoCodecs.container[0];\nvar videoCodec = supportedVideoCodecs.codec[0];\nvar _a;\nvar audioCodec = (_a = supportedAudioCodecs == null ? void 0 : supportedAudioCodecs.codec) == null ? void 0 : _a[0];\nvar defaultCodec = `video/${videoContainer};codecs=${videoCodec}${audioCodec ? `,${audioCodec}` : \"\"}`;\n\n// src/useRecordingStore.ts\nvar ERROR_MESSAGES = {\n  CODEC_NOT_SUPPORTED: \"CODEC_NOT_SUPPORTED\",\n  SESSION_EXISTS: \"SESSION_EXISTS\",\n  NO_RECORDING_WITH_ID: \"NO_RECORDING_WITH_ID\",\n  NO_USER_PERMISSION: \"NO_USER_PERMISSION\"\n};\nvar STATUS = {\n  INITIAL: \"INITIAL\",\n  CLOSED: \"CLOSED\",\n  OPEN: \"OPEN\",\n  RECORDING: \"RECORDING\",\n  STOPPED: \"STOPPED\",\n  ERROR: \"ERROR\",\n  PAUSED: \"PAUSED\"\n};\nfunction createRecording({\n  videoId,\n  audioId,\n  videoLabel,\n  audioLabel\n}) {\n  const recordingId = `${videoId}-${audioId}`;\n  const recording = {\n    id: recordingId,\n    audioId,\n    audioLabel,\n    blobChunks: [],\n    fileName: String((/* @__PURE__ */ new Date()).getTime()),\n    fileType: \"webm\",\n    isMuted: false,\n    mimeType: defaultCodec,\n    objectURL: null,\n    previewRef: createRef(),\n    recorder: null,\n    status: STATUS.INITIAL,\n    videoId,\n    videoLabel,\n    webcamRef: createRef()\n  };\n  return recording;\n}\nvar recordingMap = /* @__PURE__ */ new Map();\nvar store = createStore(recordingMap);\nfunction useRecordingStore() {\n  var _a2;\n  const { state } = useStore(store);\n  const activeRecordings = Array.from((_a2 = recordingMap == null ? void 0 : recordingMap.values) == null ? void 0 : _a2.call(recordingMap));\n  const clearAllRecordings = () => __async(this, null, function* () {\n    Array.from(state.values()).forEach((recording) => {\n      var _a3;\n      const stream = (_a3 = recording.webcamRef.current) == null ? void 0 : _a3.srcObject;\n      if (stream) {\n        stream.getTracks().forEach((track) => track.stop());\n      }\n    });\n    state.clear(true);\n  });\n  const isRecordingCreated = (recordingId) => {\n    const isCreated = state.get(recordingId);\n    return Boolean(isCreated);\n  };\n  const getRecording = (recordingId) => {\n    const recording = state.get(recordingId);\n    if (!recording) {\n      throw new Error(ERROR_MESSAGES.NO_RECORDING_WITH_ID);\n    }\n    return recording;\n  };\n  const setRecording = (params) => __async(this, null, function* () {\n    const recording = createRecording(params);\n    const newRecording = state.set(recording.id, recording, true);\n    return newRecording;\n  });\n  const updateRecording = (recordingId, updatedValues) => __async(this, null, function* () {\n    const recording = state.get(recordingId);\n    const updatedRecording = state.set(\n      recordingId,\n      __spreadValues(__spreadValues({}, recording), updatedValues),\n      true\n    );\n    return updatedRecording;\n  });\n  const deleteRecording = (recordingId) => __async(this, null, function* () {\n    state.delete(recordingId, true);\n  });\n  return {\n    activeRecordings,\n    clearAllRecordings,\n    deleteRecording,\n    getRecording,\n    isRecordingCreated,\n    setRecording,\n    updateRecording\n  };\n}\n\n// src/devices.ts\nfunction byId(devices) {\n  return devices.reduce(\n    (result, { deviceId, kind, label }) => {\n      if (kind === \"videoinput\" || kind === \"audioinput\") {\n        result[deviceId] = {\n          label,\n          type: kind\n        };\n      }\n      return result;\n    },\n    {}\n  );\n}\nfunction byType(devices) {\n  return devices.reduce(\n    (result, { deviceId, kind, label }) => {\n      if (kind === \"videoinput\") {\n        result.video.push({ label, deviceId });\n      }\n      if (kind === \"audioinput\") {\n        result.audio.push({ label, deviceId });\n      }\n      return result;\n    },\n    {\n      video: [],\n      audio: []\n    }\n  );\n}\nfunction getUserPermission() {\n  return __async(this, null, function* () {\n    try {\n      const stream = yield navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: true\n      });\n      const mediaDevices = yield navigator.mediaDevices.enumerateDevices();\n      stream.getTracks().forEach((track) => {\n        track.stop();\n      });\n      return mediaDevices;\n    } catch (error) {\n      throw new Error(ERROR_MESSAGES.NO_USER_PERMISSION);\n    }\n  });\n}\nfunction getDevices() {\n  return __async(this, null, function* () {\n    let devicesByType = {\n      video: [],\n      audio: []\n    };\n    let devicesById = {};\n    let initialDevices = {\n      video: null,\n      audio: null\n    };\n    if (typeof window !== \"undefined\") {\n      const mediaDevices = yield getUserPermission();\n      devicesById = byId(mediaDevices);\n      devicesByType = byType(mediaDevices);\n      initialDevices = {\n        video: {\n          deviceId: devicesByType.video[0].deviceId,\n          label: devicesByType.video[0].label\n        },\n        audio: {\n          deviceId: devicesByType.audio[0].deviceId,\n          label: devicesByType.audio[0].label\n        }\n      };\n    }\n    return { devicesByType, devicesById, initialDevices };\n  });\n}\nvar DEFAULT_RECORDER_OPTIONS = {\n  audioBitsPerSecond: 128e3,\n  videoBitsPerSecond: 25e5,\n  mimeType: defaultCodec\n};\nfunction useRecorder({\n  mediaRecorderOptions,\n  options,\n  devices,\n  handleError\n}) {\n  const {\n    activeRecordings,\n    clearAllRecordings,\n    deleteRecording,\n    getRecording,\n    isRecordingCreated,\n    setRecording,\n    updateRecording\n  } = useRecordingStore();\n  const recorderOptions = useMemo(\n    () => __spreadValues(__spreadValues({}, DEFAULT_RECORDER_OPTIONS), mediaRecorderOptions),\n    [mediaRecorderOptions]\n  );\n  const startRecording = (recordingId) => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      const stream = (_a2 = recording.webcamRef.current) == null ? void 0 : _a2.srcObject;\n      recording.mimeType = recorderOptions.mimeType || recording.mimeType;\n      const isCodecSupported = MediaRecorder.isTypeSupported(\n        recording.mimeType\n      );\n      if (!isCodecSupported) {\n        console.warn(\"Codec not supported: \", recording.mimeType);\n        handleError(\"startRecording\", ERROR_MESSAGES.CODEC_NOT_SUPPORTED);\n      }\n      recording.recorder = new MediaRecorder(stream, recorderOptions);\n      return yield new Promise((resolve) => {\n        var _a3;\n        if (recording.recorder) {\n          recording.recorder.ondataavailable = (event) => {\n            if (event.data.size) {\n              recording.blobChunks.push(event.data);\n            }\n          };\n          recording.recorder.onstart = () => __async(this, null, function* () {\n            recording.status = STATUS.RECORDING;\n            const updated = yield updateRecording(recording.id, recording);\n            resolve(updated);\n          });\n          recording.recorder.onerror = (error) => {\n            if (recordingId) {\n              const recording2 = getRecording(recordingId);\n              if (recording2)\n                recording2.status = STATUS.ERROR;\n            }\n            handleError(\"startRecording\", error);\n          };\n          (_a3 = recording.recorder) == null ? void 0 : _a3.start(options == null ? void 0 : options.timeSlice);\n        }\n      });\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"startRecording\", error);\n    }\n  });\n  const pauseRecording = (recordingId) => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.pause();\n      if (((_b = recording.recorder) == null ? void 0 : _b.state) === \"paused\") {\n        recording.status = STATUS.PAUSED;\n        const updated = yield updateRecording(recording.id, recording);\n        return updated;\n      }\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"pauseRecording\", error);\n    }\n  });\n  const resumeRecording = (recordingId) => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.resume();\n      if (((_b = recording.recorder) == null ? void 0 : _b.state) === \"recording\") {\n        recording.status = STATUS.RECORDING;\n        const updated = yield updateRecording(recording.id, recording);\n        return updated;\n      }\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"resumeRecording\", error);\n    }\n  });\n  const stopRecording = (recordingId) => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.stop();\n      return yield new Promise((resolve) => {\n        if (recording.recorder) {\n          recording.recorder.onstop = () => __async(this, null, function* () {\n            recording.status = STATUS.STOPPED;\n            const blob = new Blob(recording.blobChunks, {\n              type: recording.mimeType\n            });\n            const url = URL.createObjectURL(blob);\n            recording.blob = blob;\n            recording.objectURL = url;\n            if (recording.previewRef.current) {\n              recording.previewRef.current.src = url;\n            }\n            const updated = yield updateRecording(recording.id, recording);\n            resolve(updated);\n          });\n        }\n      });\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"stopRecording\", error);\n    }\n  });\n  const muteRecording = (recordingId) => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      (_a2 = recording.recorder) == null ? void 0 : _a2.stream.getAudioTracks().forEach((track) => {\n        track.enabled = !track.enabled;\n      });\n      recording.isMuted = !recording.isMuted;\n      return yield updateRecording(recording.id, recording);\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"muteRecording\", error);\n    }\n  });\n  const cancelRecording = (recordingId) => __async(this, null, function* () {\n    var _a2, _b, _c;\n    try {\n      const recording = getRecording(recordingId);\n      const tracks = (_a2 = recording == null ? void 0 : recording.recorder) == null ? void 0 : _a2.stream.getTracks();\n      (_b = recording == null ? void 0 : recording.recorder) == null ? void 0 : _b.stop();\n      tracks == null ? void 0 : tracks.forEach((track) => track.stop());\n      ((_c = recording.recorder) == null ? void 0 : _c.ondataavailable) && (recording.recorder.ondataavailable = null);\n      if (recording.webcamRef.current) {\n        const stream = recording.webcamRef.current.srcObject;\n        stream == null ? void 0 : stream.getTracks().forEach((track) => track.stop());\n        recording.webcamRef.current.srcObject = null;\n        recording.webcamRef.current.load();\n      }\n      URL.revokeObjectURL(recording.objectURL);\n      yield deleteRecording(recording.id);\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"cancelRecording\", error);\n    }\n  });\n  const createRecording2 = (videoId, audioId) => __async(this, null, function* () {\n    var _a2, _b, _c, _d, _e, _f;\n    try {\n      const { devicesById, initialDevices } = devices || {};\n      const videoLabel = videoId ? devicesById == null ? void 0 : devicesById[videoId].label : (_a2 = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _a2.label;\n      const audioLabel = audioId ? devicesById == null ? void 0 : devicesById[audioId].label : (_b = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _b.label;\n      const recordingId = `${videoId || ((_c = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _c.deviceId)}-${audioId || ((_d = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _d.deviceId)}`;\n      const isCreated = isRecordingCreated(recordingId);\n      if (isCreated)\n        throw new Error(ERROR_MESSAGES.SESSION_EXISTS);\n      const recording = yield setRecording({\n        videoId: videoId || ((_e = initialDevices == null ? void 0 : initialDevices.video) == null ? void 0 : _e.deviceId),\n        audioId: audioId || ((_f = initialDevices == null ? void 0 : initialDevices.audio) == null ? void 0 : _f.deviceId),\n        videoLabel,\n        audioLabel\n      });\n      return recording;\n    } catch (error) {\n      handleError(\"createRecording\", error);\n    }\n  });\n  const applyRecordingOptions = (recordingId) => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      if (options == null ? void 0 : options.fileName) {\n        recording.fileName = options.fileName;\n      }\n      if (options == null ? void 0 : options.fileType) {\n        recording.fileType = options.fileType;\n      }\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"applyRecordingOptions\", error);\n    }\n  });\n  const clearPreview = (recordingId) => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      if (recording.previewRef.current)\n        recording.previewRef.current.src = \"\";\n      recording.status = STATUS.INITIAL;\n      URL.revokeObjectURL(recording.objectURL);\n      recording.blobChunks = [];\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"clearPreview\", error);\n    }\n  });\n  const download = (recordingId) => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      const downloadElement = document.createElement(\"a\");\n      if (recording == null ? void 0 : recording.objectURL) {\n        downloadElement.href = recording.objectURL;\n      }\n      downloadElement.download = `${recording.fileName}.${recording.fileType}`;\n      downloadElement.click();\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"download\", error);\n    }\n  });\n  return {\n    activeRecordings,\n    applyRecordingOptions,\n    clearAllRecordings,\n    clearPreview,\n    download,\n    cancelRecording,\n    createRecording: createRecording2,\n    muteRecording,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  };\n}\n\n// src/stream.ts\nfunction startStream(videoId, audioId, constraints) {\n  return __async(this, null, function* () {\n    const newStream = yield navigator.mediaDevices.getUserMedia({\n      video: { deviceId: { exact: videoId } },\n      audio: {\n        deviceId: { exact: audioId }\n      }\n    });\n    const tracks = newStream.getTracks();\n    tracks.forEach((track) => track.applyConstraints(constraints));\n    return newStream;\n  });\n}\n\n// src/useCamera.ts\nvar DEFAULT_CONSTRAINTS = {\n  aspectRatio: 1.7,\n  echoCancellation: true,\n  height: 720,\n  width: 1280\n};\nfunction useCamera({\n  mediaTrackConstraints,\n  handleError\n}) {\n  const { getRecording, updateRecording } = useRecordingStore();\n  const constraints = useMemo(\n    () => __spreadValues(__spreadValues({}, DEFAULT_CONSTRAINTS), mediaTrackConstraints),\n    [mediaTrackConstraints]\n  );\n  const applyConstraints = (recordingId, constraints2) => __async(this, null, function* () {\n    var _a2, _b;\n    try {\n      const recording = getRecording(recordingId);\n      if ((_a2 = recording.webcamRef.current) == null ? void 0 : _a2.srcObject) {\n        const stream = (_b = recording.webcamRef.current) == null ? void 0 : _b.srcObject;\n        const tracks = stream.getTracks() || [];\n        tracks == null ? void 0 : tracks.forEach((track) => {\n          track.applyConstraints(__spreadValues({}, constraints2));\n        });\n      }\n      return recording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"applyConstraints\", error);\n    }\n  });\n  const openCamera = (recordingId) => __async(this, null, function* () {\n    try {\n      const recording = getRecording(recordingId);\n      const stream = yield startStream(\n        recording.videoId,\n        recording.audioId,\n        constraints\n      );\n      if (recording.webcamRef.current) {\n        recording.webcamRef.current.srcObject = stream;\n        yield recording.webcamRef.current.play();\n      }\n      recording.status = STATUS.OPEN;\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      handleError(\"openCamera\", error);\n    }\n  });\n  const closeCamera = (recordingId) => __async(this, null, function* () {\n    var _a2;\n    try {\n      const recording = getRecording(recordingId);\n      if (recording.webcamRef.current) {\n        const stream = recording.webcamRef.current.srcObject;\n        stream == null ? void 0 : stream.getTracks().forEach((track) => track.stop());\n        ((_a2 = recording.recorder) == null ? void 0 : _a2.ondataavailable) && (recording.recorder.ondataavailable = null);\n        recording.webcamRef.current.srcObject = null;\n        recording.webcamRef.current.load();\n      }\n      recording.status = STATUS.CLOSED;\n      const updatedRecording = yield updateRecording(recording.id, recording);\n      return updatedRecording;\n    } catch (error) {\n      if (recordingId) {\n        const recording = getRecording(recordingId);\n        if (recording)\n          recording.status = STATUS.ERROR;\n      }\n      handleError(\"closeCamera\", error);\n    }\n  });\n  return {\n    applyConstraints,\n    closeCamera,\n    openCamera\n  };\n}\nfunction useRecordWebcam({\n  mediaRecorderOptions,\n  mediaTrackConstraints,\n  options\n} = {}) {\n  const [devices, setDevices] = useState();\n  const [errorMessage, setErrorMessage] = useState(null);\n  function handleError(functionName, error) {\n    const message = typeof error === \"string\" ? error : typeof error.message === \"string\" ? error.message : \"\";\n    setErrorMessage(message);\n  }\n  function clearError() {\n    setErrorMessage(null);\n  }\n  const { applyConstraints, closeCamera, openCamera } = useCamera({\n    mediaTrackConstraints,\n    handleError\n  });\n  const {\n    activeRecordings,\n    applyRecordingOptions,\n    cancelRecording,\n    clearAllRecordings,\n    clearPreview,\n    createRecording: createRecording2,\n    download,\n    muteRecording,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  } = useRecorder({ mediaRecorderOptions, options, devices, handleError });\n  function init() {\n    return __async(this, null, function* () {\n      try {\n        const devices2 = yield getDevices();\n        setDevices(devices2);\n      } catch (error) {\n        handleError(\"init\", error);\n      }\n    });\n  }\n  useEffect(() => {\n    init();\n    return () => {\n      clearAllRecordings();\n    };\n  }, []);\n  return {\n    activeRecordings,\n    applyConstraints,\n    applyRecordingOptions,\n    cancelRecording,\n    clearAllRecordings,\n    clearError,\n    clearPreview,\n    closeCamera,\n    createRecording: createRecording2,\n    devicesById: devices == null ? void 0 : devices.devicesById,\n    devicesByType: devices == null ? void 0 : devices.devicesByType,\n    download,\n    errorMessage,\n    muteRecording,\n    openCamera,\n    pauseRecording,\n    resumeRecording,\n    startRecording,\n    stopRecording\n  };\n}\n\nexport { ERROR_MESSAGES, STATUS, checkAudioCodecPlaybackSupport, checkRecordingCodecSupport, checkVideoCodecPlaybackSupport, defaultCodec, getDevices, supportedAudioCodecs, supportedVideoCodecs, useRecordWebcam };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}